#!/usr/bin/env python3
"""
Jejak_Kuluk - Advanced Defensive Cybersecurity Monitoring Tool
A comprehensive Linux security monitoring system for intrusion detection,
log analysis, and process anomaly detection.

Author: Wayan_Choir
Team: Hornet Selem Team
License: MIT
"""

import argparse
import datetime
import json
import os
import re
import sqlite3
import subprocess
import sys
import threading
import time
from collections import defaultdict, Counter
from pathlib import Path
from typing import Dict, List, Tuple, Optional

try:
    import psutil
    from rich.console import Console
    from rich.table import Table
    from rich.live import Live
    from rich.layout import Layout
    from rich.panel import Panel
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.text import Text
    from rich import box
except ImportError:
    print("Error: Required libraries not found.")
    print("Install with: pip3 install rich psutil")
    sys.exit(1)

# Optional imports
try:
    import geoip2.database
    GEOIP_AVAILABLE = True
except ImportError:
    GEOIP_AVAILABLE = False

try:
    from scapy.all import sniff, IP, TCP
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

# Constants
VERSION = "1.0.0"
DB_PATH = os.path.expanduser("~/.jejak_kuluk.db")
GEOIP_DB_PATH = "/usr/share/GeoIP/GeoLite2-City.mmdb"

# ASCII Banner
BANNER = """
[bold cyan]
   ____.       __          __           ____  __.      .__          __    
  |    | ____ |__|____    |  | __      |    |/ _|__ __|  |  __ __ |  | __
  |    |/ __ \|  \__  \   |  |/ /      |      < |  |  \  | |  |  \|  |/ /
/\__|    \  ___/| |/ __ \_ |    <       |    |  \|  |  /  |_|  |  /    < 
\________|\___  >__(____  / |__|_ \     |____|__ \____/|____/____/|__|_ \\
              \/        \/       \/             \/                      \/
[/bold cyan]
[bold yellow]Created by:[/bold yellow] [cyan]Wayan_Choir[/cyan]
[bold yellow]Developed by:[/bold yellow] [cyan]Hornet Selem Team[/cyan]
[bold green]Open Source Project â€” Contribute now![/bold green]
[dim]Version {version}[/dim]
""".format(version=VERSION)

console = Console()


class Database:
    """SQLite database manager for storing security events."""
    
    def __init__(self, db_path: str = DB_PATH):
        self.db_path = db_path
        self.init_db()
    
    def init_db(self):
        """Initialize database tables."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Events table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                event_type TEXT NOT NULL,
                ip_address TEXT,
                username TEXT,
                port INTEGER,
                country TEXT,
                city TEXT,
                risk_score INTEGER,
                raw_log TEXT,
                fingerprint TEXT
            )
        """)
        
        # Process anomalies table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS process_anomalies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                pid INTEGER,
                name TEXT,
                cpu_percent REAL,
                memory_percent REAL,
                connections INTEGER,
                risk_level TEXT
            )
        """)
        
        conn.commit()
        conn.close()
    
    def insert_event(self, event_data: Dict):
        """Insert security event into database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO events (timestamp, event_type, ip_address, username, 
                              port, country, city, risk_score, raw_log, fingerprint)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            event_data.get('timestamp'),
            event_data.get('event_type'),
            event_data.get('ip_address'),
            event_data.get('username'),
            event_data.get('port'),
            event_data.get('country'),
            event_data.get('city'),
            event_data.get('risk_score'),
            event_data.get('raw_log'),
            event_data.get('fingerprint')
        ))
        
        conn.commit()
        conn.close()
    
    def get_events(self, limit: int = 100, event_type: str = None) -> List[Dict]:
        """Retrieve events from database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if event_type:
            cursor.execute("""
                SELECT * FROM events WHERE event_type = ? 
                ORDER BY timestamp DESC LIMIT ?
            """, (event_type, limit))
        else:
            cursor.execute("""
                SELECT * FROM events ORDER BY timestamp DESC LIMIT ?
            """, (limit,))
        
        columns = [desc[0] for desc in cursor.description]
        events = [dict(zip(columns, row)) for row in cursor.fetchall()]
        
        conn.close()
        return events
    
    def insert_process_anomaly(self, process_data: Dict):
        """Insert process anomaly into database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO process_anomalies (timestamp, pid, name, cpu_percent, 
                                          memory_percent, connections, risk_level)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (
            process_data.get('timestamp'),
            process_data.get('pid'),
            process_data.get('name'),
            process_data.get('cpu_percent'),
            process_data.get('memory_percent'),
            process_data.get('connections'),
            process_data.get('risk_level')
        ))
        
        conn.commit()
        conn.close()


class GeoIPLookup:
    """GeoIP lookup handler."""
    
    def __init__(self):
        self.available = GEOIP_AVAILABLE
        self.reader = None
        
        if self.available and os.path.exists(GEOIP_DB_PATH):
            try:
                self.reader = geoip2.database.Reader(GEOIP_DB_PATH)
            except Exception as e:
                console.print(f"[yellow]GeoIP database error: {e}[/yellow]")
                self.available = False
    
    def lookup(self, ip: str) -> Tuple[str, str, str]:
        """Lookup IP address geolocation."""
        if not self.available or not self.reader:
            return "Unknown", "Unknown", "Unknown"
        
        try:
            response = self.reader.city(ip)
            country = response.country.name or "Unknown"
            city = response.city.name or "Unknown"
            asn = response.traits.autonomous_system_organization or "Unknown"
            return country, city, asn
        except Exception:
            return "Unknown", "Unknown", "Unknown"
    
    def close(self):
        """Close GeoIP database."""
        if self.reader:
            self.reader.close()


class LogAnalyzer:
    """Analyze system logs for security events."""
    
    def __init__(self, geoip: GeoIPLookup):
        self.geoip = geoip
        self.log_paths = {
            'auth': '/var/log/auth.log',
            'syslog': '/var/log/syslog',
            'nginx_access': '/var/log/nginx/access.log',
            'nginx_error': '/var/log/nginx/error.log',
        }
        
        # Regex patterns
        self.patterns = {
            'ssh_failed': re.compile(r'Failed password for (?:invalid user )?(\S+) from (\S+) port (\d+)'),
            'ssh_accepted': re.compile(r'Accepted password for (\S+) from (\S+) port (\d+)'),
            'ssh_disconnect': re.compile(r'Disconnected from (?:invalid user )?(\S+) (\S+) port (\d+)'),
            'sudo_command': re.compile(r'sudo:\s+(\S+) : TTY=\S+ ; PWD=\S+ ; USER=\S+ ; COMMAND=(.+)'),
            'nginx_request': re.compile(r'(\S+) - - \[(.*?)\] "(\S+) (\S+) (\S+)" (\d+) (\d+)'),
        }
    
    def read_log(self, log_type: str, lines: int = 1000) -> List[str]:
        """Read log file."""
        log_path = self.log_paths.get(log_type)
        if not log_path or not os.path.exists(log_path):
            return []
        
        try:
            with open(log_path, 'r', errors='ignore') as f:
                return f.readlines()[-lines:]
        except PermissionError:
            console.print(f"[red]Permission denied: {log_path}[/red]")
            console.print("[yellow]Try running with sudo[/yellow]")
            return []
        except Exception as e:
            console.print(f"[red]Error reading {log_path}: {e}[/red]")
            return []
    
    def parse_auth_log(self, lines: List[str]) -> List[Dict]:
        """Parse authentication logs."""
        events = []
        
        for line in lines:
            # Failed SSH login
            match = self.patterns['ssh_failed'].search(line)
            if match:
                username, ip, port = match.groups()
                country, city, asn = self.geoip.lookup(ip)
                
                event = {
                    'timestamp': self._extract_timestamp(line),
                    'event_type': 'ssh_failed',
                    'ip_address': ip,
                    'username': username,
                    'port': int(port),
                    'country': country,
                    'city': city,
                    'risk_score': self._calculate_risk(ip, 'ssh_failed'),
                    'raw_log': line.strip(),
                    'fingerprint': f"{ip}:{port}:{username}"
                }
                events.append(event)
                continue
            
            # Successful SSH login
            match = self.patterns['ssh_accepted'].search(line)
            if match:
                username, ip, port = match.groups()
                country, city, asn = self.geoip.lookup(ip)
                
                event = {
                    'timestamp': self._extract_timestamp(line),
                    'event_type': 'ssh_accepted',
                    'ip_address': ip,
                    'username': username,
                    'port': int(port),
                    'country': country,
                    'city': city,
                    'risk_score': self._calculate_risk(ip, 'ssh_accepted'),
                    'raw_log': line.strip(),
                    'fingerprint': f"{ip}:{port}:{username}"
                }
                events.append(event)
                continue
            
            # Sudo command
            match = self.patterns['sudo_command'].search(line)
            if match:
                username, command = match.groups()
                
                event = {
                    'timestamp': self._extract_timestamp(line),
                    'event_type': 'sudo_command',
                    'ip_address': None,
                    'username': username,
                    'port': None,
                    'country': 'Local',
                    'city': 'Local',
                    'risk_score': self._calculate_risk(None, 'sudo_command', command),
                    'raw_log': line.strip(),
                    'fingerprint': f"local:{username}:{command[:50]}"
                }
                events.append(event)
        
        return events
    
    def parse_nginx_log(self, lines: List[str]) -> List[Dict]:
        """Parse nginx access logs."""
        events = []
        
        for line in lines:
            match = self.patterns['nginx_request'].search(line)
            if match:
                ip, timestamp, method, path, protocol, status, size = match.groups()
                country, city, asn = self.geoip.lookup(ip)
                
                event = {
                    'timestamp': timestamp,
                    'event_type': 'http_request',
                    'ip_address': ip,
                    'username': None,
                    'port': 80,
                    'country': country,
                    'city': city,
                    'risk_score': self._calculate_risk(ip, 'http_request', path, int(status)),
                    'raw_log': line.strip(),
                    'fingerprint': f"{ip}:{method}:{path}"
                }
                events.append(event)
        
        return events
    
    def _extract_timestamp(self, log_line: str) -> str:
        """Extract timestamp from log line."""
        # Try to extract standard syslog timestamp
        match = re.match(r'(\w+\s+\d+\s+\d+:\d+:\d+)', log_line)
        if match:
            return match.group(1)
        return datetime.datetime.now().strftime("%b %d %H:%M:%S")
    
    def _calculate_risk(self, ip: str, event_type: str, extra: str = None, status: int = None) -> int:
        """Calculate risk score for event."""
        score = 0
        
        # Base scores
        if event_type == 'ssh_failed':
            score = 70
        elif event_type == 'ssh_accepted':
            score = 30
        elif event_type == 'sudo_command':
            score = 40
            if extra and any(cmd in extra.lower() for cmd in ['rm -rf', 'chmod', 'wget', 'curl']):
                score = 80
        elif event_type == 'http_request':
            score = 10
            if extra and any(pattern in extra.lower() for pattern in ['admin', 'wp-admin', '.env', 'config', 'sql']):
                score = 60
            if status and status >= 400:
                score += 20
        
        return min(score, 100)
    
    def detect_brute_force(self, events: List[Dict], threshold: int = 5, time_window: int = 300) -> List[Dict]:
        """Detect brute force attacks."""
        ip_attempts = defaultdict(list)
        alerts = []
        
        for event in events:
            if event['event_type'] == 'ssh_failed' and event['ip_address']:
                ip_attempts[event['ip_address']].append(event)
        
        for ip, attempts in ip_attempts.items():
            if len(attempts) >= threshold:
                alerts.append({
                    'type': 'brute_force',
                    'ip': ip,
                    'attempts': len(attempts),
                    'usernames': list(set(a['username'] for a in attempts)),
                    'first_seen': attempts[0]['timestamp'],
                    'last_seen': attempts[-1]['timestamp']
                })
        
        return alerts


class ProcessMonitor:
    """Monitor running processes for anomalies."""
    
    def __init__(self):
        self.baseline_procs = set()
        self.suspicious_patterns = [
            'nc', 'netcat', 'ncat', 'socat', 'reverse',
            'metasploit', 'meterpreter', 'mimikatz',
            'cryptominer', 'xmrig', 'minerd'
        ]
    
    def get_processes(self) -> List[Dict]:
        """Get all running processes with details."""
        processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'username', 'cpu_percent', 'memory_percent']):
            try:
                pinfo = proc.info
                connections = len(proc.connections()) if proc.connections else 0
                
                # Calculate risk
                risk_level = self._assess_risk(pinfo['name'], pinfo['cpu_percent'], 
                                               pinfo['memory_percent'], connections)
                
                processes.append({
                    'pid': pinfo['pid'],
                    'name': pinfo['name'],
                    'username': pinfo['username'],
                    'cpu_percent': pinfo['cpu_percent'] or 0.0,
                    'memory_percent': pinfo['memory_percent'] or 0.0,
                    'connections': connections,
                    'risk_level': risk_level
                })
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                continue
        
        return sorted(processes, key=lambda x: x['cpu_percent'], reverse=True)
    
    def _assess_risk(self, name: str, cpu: float, memory: float, connections: int) -> str:
        """Assess process risk level."""
        # Check for suspicious process names
        if any(pattern in name.lower() for pattern in self.suspicious_patterns):
            return 'HIGH'
        
        # High resource usage
        if cpu > 80 or memory > 80:
            return 'MEDIUM'
        
        # Many network connections
        if connections > 50:
            return 'MEDIUM'
        
        return 'LOW'
    
    def detect_anomalies(self, processes: List[Dict]) -> List[Dict]:
        """Detect anomalous processes."""
        anomalies = []
        
        for proc in processes:
            if proc['risk_level'] in ['HIGH', 'MEDIUM']:
                anomalies.append(proc)
        
        return anomalies


class NetworkMonitor:
    """Monitor network traffic using scapy."""
    
    def __init__(self):
        self.available = SCAPY_AVAILABLE
        self.port_scan_threshold = 10
        self.port_scans = defaultdict(set)
    
    def packet_callback(self, packet):
        """Process captured packets."""
        if not packet.haslayer(IP):
            return
        
        ip_src = packet[IP].src
        
        if packet.haslayer(TCP):
            dst_port = packet[TCP].dport
            self.port_scans[ip_src].add(dst_port)
            
            # Detect port scan
            if len(self.port_scans[ip_src]) > self.port_scan_threshold:
                console.print(f"[red]âš ï¸  Port scan detected from {ip_src}[/red]")
    
    def start_monitoring(self, duration: int = 60):
        """Start network monitoring."""
        if not self.available:
            console.print("[yellow]Scapy not available. Install with: pip3 install scapy[/yellow]")
            return
        
        console.print(f"[cyan]Monitoring network traffic for {duration} seconds...[/cyan]")
        try:
            sniff(prn=self.packet_callback, timeout=duration, store=0)
        except PermissionError:
            console.print("[red]Permission denied. Run with sudo for network monitoring.[/red]")
        except Exception as e:
            console.print(f"[red]Network monitoring error: {e}[/red]")


class Dashboard:
    """Interactive TUI dashboard."""
    
    def __init__(self, db: Database, analyzer: LogAnalyzer, process_monitor: ProcessMonitor):
        self.db = db
        self.analyzer = analyzer
        self.process_monitor = process_monitor
        self.running = True
    
    def generate_layout(self) -> Layout:
        """Generate dashboard layout."""
        layout = Layout()
        
        layout.split_column(
            Layout(name="header", size=3),
            Layout(name="body"),
            Layout(name="footer", size=3)
        )
        
        layout["body"].split_row(
            Layout(name="left"),
            Layout(name="right")
        )
        
        return layout
    
    def generate_header(self) -> Panel:
        """Generate header panel."""
        header_text = Text()
        header_text.append("Jejak_Kuluk Dashboard", style="bold cyan")
        header_text.append(" | ", style="dim")
        header_text.append(f"Time: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", style="yellow")
        
        return Panel(header_text, box=box.ROUNDED)
    
    def generate_events_table(self) -> Table:
        """Generate recent events table."""
        table = Table(title="Recent Security Events", box=box.ROUNDED, show_header=True, header_style="bold cyan")
        
        table.add_column("Time", style="yellow", width=12)
        table.add_column("Type", style="cyan", width=15)
        table.add_column("IP", style="magenta", width=15)
        table.add_column("User", style="green", width=12)
        table.add_column("Risk", style="red", width=8)
        
        events = self.db.get_events(limit=10)
        
        for event in events:
            risk_score = event.get('risk_score', 0)
            risk_color = "green" if risk_score < 40 else "yellow" if risk_score < 70 else "red"
            risk_emoji = "ðŸŸ©" if risk_score < 40 else "ðŸŸ¨" if risk_score < 70 else "ðŸŸ¥"
            
            table.add_row(
                event.get('timestamp', '')[:12],
                event.get('event_type', ''),
                event.get('ip_address', 'N/A'),
                event.get('username', 'N/A'),
                f"{risk_emoji} {risk_score}"
            )
        
        return table
    
    def generate_process_table(self) -> Table:
        """Generate process monitoring table."""
        table = Table(title="Process Monitor", box=box.ROUNDED, show_header=True, header_style="bold cyan")
        
        table.add_column("PID", style="yellow", width=8)
        table.add_column("Name", style="cyan", width=20)
        table.add_column("CPU%", style="green", width=8)
        table.add_column("MEM%", style="blue", width=8)
        table.add_column("Risk", style="red", width=10)
        
        processes = self.process_monitor.get_processes()[:10]
        
        for proc in processes:
            risk_color = "green" if proc['risk_level'] == 'LOW' else "yellow" if proc['risk_level'] == 'MEDIUM' else "red"
            
            table.add_row(
                str(proc['pid']),
                proc['name'][:20],
                f"{proc['cpu_percent']:.1f}",
                f"{proc['memory_percent']:.1f}",
                f"[{risk_color}]{proc['risk_level']}[/{risk_color}]"
            )
        
        return table
    
    def generate_stats_panel(self) -> Panel:
        """Generate statistics panel."""
        events = self.db.get_events(limit=100)
        
        total_events = len(events)
        failed_logins = sum(1 for e in events if e.get('event_type') == 'ssh_failed')
        high_risk = sum(1 for e in events if e.get('risk_score', 0) > 70)
        
        stats_text = Text()
        stats_text.append("Statistics\n", style="bold cyan")
        stats_text.append(f"Total Events: {total_events}\n", style="yellow")
        stats_text.append(f"Failed Logins: {failed_logins}\n", style="red")
        stats_text.append(f"High Risk: {high_risk}\n", style="red bold")
        
        return Panel(stats_text, box=box.ROUNDED, title="Stats")
    
    def run(self):
        """Run interactive dashboard."""
        with Live(self.generate_layout(), refresh_per_second=1, console=console) as live:
            while self.running:
                try:
                    layout = self.generate_layout()
                    
                    layout["header"].update(self.generate_header())
                    layout["left"].update(self.generate_events_table())
                    layout["right"].split_column(
                        Layout(self.generate_process_table()),
                        Layout(self.generate_stats_panel())
                    )
                    layout["footer"].update(Panel("Press Ctrl+C to exit", style="dim"))
                    
                    live.update(layout)
                    time.sleep(1)
                except KeyboardInterrupt:
                    self.running = False
                    break


def analyze_command(args):
    """Analyze system logs."""
    console.print(BANNER)
    console.print("[bold cyan]ðŸ“Š Analyzing System Logs...[/bold cyan]\n")
    
    db = Database()
    geoip = GeoIPLookup()
    analyzer = LogAnalyzer(geoip)
    
    # Parse authentication logs
    with console.status("[cyan]Reading auth logs..."):
        auth_lines = analyzer.read_log('auth', lines=args.lines)
        auth_events = analyzer.parse_auth_log(auth_lines)
    
    console.print(f"[green]âœ“[/green] Parsed {len(auth_events)} authentication events")
    
    # Parse nginx logs if available
    nginx_lines = analyzer.read_log('nginx_access', lines=args.lines)
    if nginx_lines:
        nginx_events = analyzer.parse_nginx_log(nginx_lines)
        console.print(f"[green]âœ“[/green] Parsed {len(nginx_events)} HTTP requests")
    else:
        nginx_events = []
    
    all_events = auth_events + nginx_events
    
    # Store in database
    with console.status("[cyan]Storing events in database..."):
        for event in all_events:
            db.insert_event(event)
    
    # Detect brute force
    brute_force = analyzer.detect_brute_force(auth_events)
    
    # Display results
    table = Table(title="Recent Security Events", box=box.ROUNDED, show_header=True, header_style="bold cyan")
    table.add_column("Time", style="yellow")
    table.add_column("Type", style="cyan")
    table.add_column("IP", style="magenta")
    table.add_column("User", style="green")
    table.add_column("Location", style="blue")
    table.add_column("Risk", style="red")
    
    for event in all_events[:20]:
        risk_score = event['risk_score']
        risk_emoji = "ðŸŸ©" if risk_score < 40 else "ðŸŸ¨" if risk_score < 70 else "ðŸŸ¥"
        
        table.add_row(
            event['timestamp'][:20],
            event['event_type'],
            event['ip_address'] or 'N/A',
            event['username'] or 'N/A',
            f"{event['country']}, {event['city']}",
            f"{risk_emoji} {risk_score}"
        )
    
    console.print("\n", table)
    
    # Display brute force alerts
    if brute_force:
        console.print("\n[bold red]ðŸš¨ BRUTE FORCE ATTACKS DETECTED:[/bold red]")
        for alert in brute_force:
            console.print(f"  [red]âš ï¸  IP: {alert['ip']} - {alert['attempts']} attempts[/red]")
            console.print(f"     Usernames: {', '.join(alert['usernames'][:5])}")
    
    geoip.close()


def live_command(args):
    """Live monitoring mode."""
    console.print(BANNER)
    console.print("[bold cyan]ðŸ”´ Live Monitoring Mode (Press Ctrl+C to stop)[/bold cyan]\n")
    
    db = Database()
    geoip = GeoIPLookup()
    analyzer = LogAnalyzer(geoip)
    
    seen_events = set()
    
    try:
        while True:
            auth_lines = analyzer.read_log('auth', lines=50)
            events = analyzer.parse_auth_log(auth_lines)
            
            for event in events:
                fingerprint = event['fingerprint']
                if fingerprint not in seen_events:
                    seen_events.add(fingerprint)
                    db.insert_event(event)
                    
                    risk_score = event['risk_score']
                    risk_emoji = "ðŸŸ©" if risk_score < 40 else "ðŸŸ¨" if risk_score < 70 else "ðŸŸ¥"
                    
                    console.print(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] {risk_emoji} "
                                f"{event['event_type']} - {event['ip_address']} "
                                f"({event['country']}) - Risk: {risk_score}")
            
            time.sleep(5)
    except KeyboardInterrupt:
        console.print("\n[yellow]Monitoring stopped.[/yellow]")
    
    geoip.close()


def dashboard_command(args):
    """Interactive dashboard mode."""
    console.print(BANNER)
    
    db = Database()
    geoip = GeoIPLookup()
    analyzer = LogAnalyzer(geoip)
    process_monitor = ProcessMonitor()
    
    dashboard = Dashboard(db, analyzer, process_monitor)
    
    try:
        dashboard.run()
    except KeyboardInterrupt:
        console.print("\n[yellow]Dashboard closed.[/yellow]")
    
    geoip.close()


def process_command(args):
    """Process anomaly monitoring."""
    console.print(BANNER)
    console.print("[bold cyan]ðŸ” Process Anomaly Monitor[/bold cyan]\n")
    
    monitor = ProcessMonitor()
    db = Database()
    
    try:
        while True:
            processes = monitor.get_processes()
            anomalies = monitor.detect_anomalies(processes)
            
            # Create table
            table = Table(title="Running Processes (Top 20)", box=box.ROUNDED, show_header=True, header_style="bold cyan")
            table.add_column("PID", style="yellow", width=8)
            table.add_column("Name", style="cyan", width=25)
            table.add_column("User", style="green", width=15)
            table.add_column("CPU%", style="magenta", width=8)
            table.add_column("MEM%", style="blue", width=8)
            table.add_column("Connections", style="yellow", width=12)
            table.add_column("Risk", style="red", width=10)
            
            for proc in processes[:20]:
                risk_color = "green" if proc['risk_level'] == 'LOW' else "yellow" if proc['risk_level'] == 'MEDIUM' else "red"
                name_color = "red bold" if proc['risk_level'] == 'HIGH' else "cyan"
                
                table.add_row(
                    str(proc['pid']),
                    f"[{name_color}]{proc['name'][:25]}[/{name_color}]",
                    proc['username'][:15],
                    f"{proc['cpu_percent']:.1f}",
                    f"{proc['memory_percent']:.1f}",
                    str(proc['connections']),
                    f"[{risk_color}]{proc['risk_level']}[/{risk_color}]"
                )
            
            console.clear()
            console.print(BANNER)
            console.print(f"[dim]Updated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}[/dim]\n")
            console.print(table)
            
            # Display anomalies
            if anomalies:
                console.print("\n[bold red]âš ï¸  ANOMALIES DETECTED:[/bold red]")
                for proc in anomalies[:5]:
                    console.print(f"  [red]â€¢ {proc['name']} (PID: {proc['pid']}) - {proc['risk_level']} risk[/red]")
                    
                    # Store in database
                    db.insert_process_anomaly({
                        'timestamp': datetime.datetime.now().isoformat(),
                        'pid': proc['pid'],
                        'name': proc['name'],
                        'cpu_percent': proc['cpu_percent'],
                        'memory_percent': proc['memory_percent'],
                        'connections': proc['connections'],
                        'risk_level': proc['risk_level']
                    })
            
            console.print("\n[dim]Press Ctrl+C to exit[/dim]")
            time.sleep(2)
            
    except KeyboardInterrupt:
        console.print("\n[yellow]Process monitor stopped.[/yellow]")


def export_command(args):
    """Export security report."""
    console.print(BANNER)
    console.print("[bold cyan]ðŸ“¤ Exporting Security Report...[/bold cyan]\n")
    
    db = Database()
    events = db.get_events(limit=args.limit)
    
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    if args.format == 'json':
        filename = f"jejak_kuluk_report_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(events, f, indent=2)
        console.print(f"[green]âœ“[/green] Report exported to: {filename}")
    
    elif args.format == 'log':
        filename = f"jejak_kuluk_report_{timestamp}.log"
        with open(filename, 'w') as f:
            f.write(f"Jejak_Kuluk Security Report - {datetime.datetime.now()}\n")
            f.write("=" * 80 + "\n\n")
            
            for event in events:
                f.write(f"[{event.get('timestamp')}] {event.get('event_type')}\n")
                f.write(f"  IP: {event.get('ip_address')} | User: {event.get('username')}\n")
                f.write(f"  Location: {event.get('country')}, {event.get('city')}\n")
                f.write(f"  Risk Score: {event.get('risk_score')}\n")
                f.write(f"  Raw: {event.get('raw_log')}\n")
                f.write("-" * 80 + "\n")
        
        console.print(f"[green]âœ“[/green] Report exported to: {filename}")


def trace_command(args):
    """Trace and fingerprint intruders."""
    console.print(BANNER)
    console.print("[bold cyan]ðŸ”Ž Tracing Intruder Activities...[/bold cyan]\n")
    
    db = Database()
    
    if args.ip:
        # Trace specific IP
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM events WHERE ip_address = ? ORDER BY timestamp DESC", (args.ip,))
        columns = [desc[0] for desc in cursor.description]
        events = [dict(zip(columns, row)) for row in cursor.fetchall()]
        conn.close()
        
        if not events:
            console.print(f"[yellow]No events found for IP: {args.ip}[/yellow]")
            return
        
        console.print(f"[bold cyan]Fingerprint for IP: {args.ip}[/bold cyan]\n")
        
        # Statistics
        event_types = Counter(e['event_type'] for e in events)
        usernames = Counter(e['username'] for e in events if e['username'])
        
        console.print(f"[green]Total Events:[/green] {len(events)}")
        console.print(f"[green]Location:[/green] {events[0]['country']}, {events[0]['city']}")
        console.print(f"[green]Event Types:[/green] {dict(event_types)}")
        console.print(f"[green]Attempted Usernames:[/green] {list(usernames.keys())[:10]}")
        console.print(f"[green]First Seen:[/green] {events[-1]['timestamp']}")
        console.print(f"[green]Last Seen:[/green] {events[0]['timestamp']}")
        
        # Timeline
        console.print("\n[bold cyan]Timeline:[/bold cyan]")
        table = Table(box=box.ROUNDED, show_header=True, header_style="bold cyan")
        table.add_column("Time", style="yellow")
        table.add_column("Event", style="cyan")
        table.add_column("Details", style="green")
        table.add_column("Risk", style="red")
        
        for event in events[:20]:
            risk_emoji = "ðŸŸ©" if event['risk_score'] < 40 else "ðŸŸ¨" if event['risk_score'] < 70 else "ðŸŸ¥"
            table.add_row(
                event['timestamp'][:20],
                event['event_type'],
                event['username'] or 'N/A',
                f"{risk_emoji} {event['risk_score']}"
            )
        
        console.print(table)
    
    else:
        # List all high-risk IPs
        events = db.get_events(limit=1000)
        high_risk_ips = defaultdict(list)
        
        for event in events:
            if event['risk_score'] > 60 and event['ip_address']:
                high_risk_ips[event['ip_address']].append(event)
        
        console.print("[bold red]High Risk IP Addresses:[/bold red]\n")
        
        table = Table(box=box.ROUNDED, show_header=True, header_style="bold cyan")
        table.add_column("IP", style="magenta")
        table.add_column("Events", style="yellow")
        table.add_column("Location", style="blue")
        table.add_column("Avg Risk", style="red")
        
        for ip, ip_events in sorted(high_risk_ips.items(), key=lambda x: len(x[1]), reverse=True)[:20]:
            avg_risk = sum(e['risk_score'] for e in ip_events) / len(ip_events)
            risk_emoji = "ðŸŸ¨" if avg_risk < 70 else "ðŸŸ¥"
            
            table.add_row(
                ip,
                str(len(ip_events)),
                f"{ip_events[0]['country']}, {ip_events[0]['city']}",
                f"{risk_emoji} {avg_risk:.0f}"
            )
        
        console.print(table)
        console.print(f"\n[dim]Use 'jejak_kuluk trace --ip <IP>' to see detailed fingerprint[/dim]")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Jejak_Kuluk - Advanced Defensive Cybersecurity Monitoring Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  jejak_kuluk analyze              Analyze system logs
  jejak_kuluk live                 Start live monitoring
  jejak_kuluk dashboard            Launch interactive dashboard
  jejak_kuluk process              Monitor process anomalies
  jejak_kuluk trace --ip 1.2.3.4   Trace specific IP
  jejak_kuluk export --format json Export report to JSON
        """
    )
    
    parser.add_argument('--version', action='version', version=f'Jejak_Kuluk {VERSION}')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Analyze command
    analyze_parser = subparsers.add_parser('analyze', help='Analyze system logs')
    analyze_parser.add_argument('-l', '--lines', type=int, default=1000, help='Number of log lines to analyze')
    
    # Live command
    live_parser = subparsers.add_parser('live', help='Live monitoring mode')
    
    # Dashboard command
    dashboard_parser = subparsers.add_parser('dashboard', help='Interactive dashboard')
    
    # Process command
    process_parser = subparsers.add_parser('process', help='Process anomaly monitor')
    
    # Export command
    export_parser = subparsers.add_parser('export', help='Export security report')
    export_parser.add_argument('-f', '--format', choices=['json', 'log'], default='json', help='Export format')
    export_parser.add_argument('-l', '--limit', type=int, default=1000, help='Number of events to export')
    
    # Trace command
    trace_parser = subparsers.add_parser('trace', help='Trace intruder activities')
    trace_parser.add_argument('-i', '--ip', help='IP address to trace')
    
    args = parser.parse_args()
    
    if not args.command:
        console.print(BANNER)
        parser.print_help()
        return
    
    # Route to appropriate command
    commands = {
        'analyze': analyze_command,
        'live': live_command,
        'dashboard': dashboard_command,
        'process': process_command,
        'export': export_command,
        'trace': trace_command
    }
    
    if args.command in commands:
        try:
            commands[args.command](args)
        except KeyboardInterrupt:
            console.print("\n[yellow]Operation cancelled.[/yellow]")
        except Exception as e:
            console.print(f"\n[red]Error: {e}[/red]")
            if '--debug' in sys.argv:
                raise
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
